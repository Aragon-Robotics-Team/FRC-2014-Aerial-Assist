#include "WPILib.h"
#include "Gamepad.h"
#include "Compressor.h"
#include <Relay.h>
#include "VelocityEncoder.h"

const char VERSION[] = "0.1.1 Week Before Davis";

const float JOY_DIR = 1;
const float GAMEPAD_JOY_DIR = -1;

const float CREEP_SPEED = 0.5;
const float CLAW_SPEED = 0.4;

const float KP = 0.5;
const float KI = 0.0;
const float KD = 0.0;

const float ARM_KP = -0.4;
const float ARM_KI = -0.005;
const float ARM_KD = -0.005;

const float GAMEPAD_JOY_THRESH = 0.05;

const float PI = 3.14159265358979;
const float FEET_PER_TICK = ((4 * PI) / 12) / 1200;

class Robot : public SimpleRobot
{
	DriverStationLCD *ds;
	
	/* AxisCamera *camera; */
	
	Talon leftDriveMotor, rightDriveMotor;
	Talon arm, rollers;
	
	Compressor compressor;
	
	Relay shooterSolenoid;
	
	Encoder leftEncoder, rightEncoder;
	Encoder armEncoder;
	
	Gyro gyro;
	
	DigitalInput armSwitchBot;
	DigitalInput armSwitchTop;
	
	Joystick leftStick, rightStick;
	Gamepad gamepad;
	
	PIDController leftPID, rightPID; //Use these to drive straight + measured
	PIDController armPID;
	
	Watchdog doggy;
	
	
	float holdPosition;

public:
	Robot():
		leftDriveMotor(10),
		rightDriveMotor(1),
		arm(3),
		rollers(6),
		
		compressor(1, 1),
		
		shooterSolenoid(2, Relay::kBothDirections),
		
		leftEncoder(5, 6),
		rightEncoder(7, 8),
		armEncoder(9, 10),
		
		gyro(5),
		
		armSwitchBot(1),	//CALIBRATE: Get port later
		armSwitchTop(1)		//CALIBRATE: Get port later
		
		leftStick(1),
		rightStick(2),
		gamepad(3),
		
		leftPID(KP, KI, KD, &leftEncoder, &leftDriveMotor),
		rightPID(KP, KI, KD, &rightEncoder, &rightDriveMotor),
		armPID(ARM_KP, ARM_KI, ARM_KD, &armEncoder, &arm),
			
		doggy(),
		

	{
		leftEncoder.SetDistancePerPulse(FEET_PER_TICK);
		rightEncoder.SetDistancePerPulse(FEET_PER_TICK);
		armEncoder.SetDistancePerPulse(0.01);	//1 to 1 ratio, GetDistance() returns ticks
		
		doggy.SetEnabled(true);
		doggy.SetExpiration(1.0);
		
		shooterSolenoid.Set(Relay::kOff);
		
		holdPosition = 0;
	}
	
	//Limits maximum change in acceleration to protect chains
	/* void softStart(float& currentSpeed, float inputValue){
		currentSpeed = 0.99 * currentSpeed + 0.01 * inputValue;
	} */
	
	void startStraightPID(){	//Clears and initiates driving PID
		leftPID.Reset();
		rightPID.Reset();
		leftPID.Enable();
		rightPID.Enable();
		leftPID.SetContinuous();
		rightPID.SetContinuous();
	}
	
	void setStraightPID(float setpoint){	//Sets straight direction for driving PID
		leftPID.SetSetpoint(setpoint);
		rightPID.SetSetpoint(setpoint);
	}
	
	void disableStraightPID(){	//Disables driving PID
		leftPID.Disable();
		rightPID.Disable();
	}
	
	void startArmPID(){	//Clears and initiates arm PID
		armPID.Reset();
		armPID.Enable();
		armPID.SetContinuous();
	}

	void Autonomous()
	{
		Timer autonomousTimer;
		autonomousTimer.Start();
		
		doggy.SetEnabled(false);
		
		ds = DriverStationLCD::GetInstance();
		
		ds->PrintfLine(DriverStationLCD::kUser_Line1, "Starting autonomous...");
		ds->UpdateLCD();
		
		arm.Set(.25);
		while(!armSwitchTop.Get()); //Wait for arm to reach top position
		arm.Set(0);
		armEncoder.Reset(); /* Reset the arm encoder based on limit switch absolute position */
		armEncoder.Start();
		//startArmPID();
		while(autonomousTimer.Get() < 10){
			ds->PrintfLine(DriverStationLCD::kUser_Line2, "Arm encoder: %f", armEncoder.GetDistance());
			ds->PrintfLine(DriverStationLCD::kUser_Line3, "ArmPID error: %f", armPID.GetError());
			ds->PrintfLine(DriverStationLCD::kUser_Line4, "Time: %f", autonomousTimer.Get());
			ds->UpdateLCD();
		}
		
		shooterSolenoid.Set(Relay::kForward);
		leftPID.SetSetpoint(10);	//Units in feet
		rightPID.SetSetpoint(10);
		
		ds->PrintfLine(DriverStationLCD::kUser_Line5, "Autonomous done.");
		ds->UpdateLCD();
		
		/* leftEncoder.Start();
		rightEncoder.Start();
		
		startStraightPID();
		setStraightPID(10);
		
		while(autonomousTimer.Get() < 10){
			ds = DriverStationLCD::GetInstance();
			
			ds->PrintfLine(DriverStationLCD::kUser_Line1, "Encoders: %f, %f", leftEncoder.GetDistance(), rightEncoder.GetDistance());
			ds->PrintfLine(DriverStationLCD::kUser_Line2, "Straight error: %f, %f", leftPID.GetError(), rightPID.GetError());
			ds->UpdateLCD();
		}
		disableStraightPID(); */
	}
	
	void updateDriverStation(){	//Updates the console of the driver station with current sensor readings
		ds = DriverStationLCD::GetInstance();
		
		ds->PrintfLine(DriverStationLCD::kUser_Line1, VERSION);	//Prints version number
		ds->PrintfLine(DriverStationLCD::kUser_Line2, "Arm: %f", armEncoder.GetDistance());	//Prints arm encoder value
		ds->PrintfLine(DriverStationLCD::kUser_Line3, "Arm Error: %f, %f", armPID.GetError()); //Prints the arm's PID error
		ds->PrintfLine(DriverStationLCD::kUser_Line4, "C. Switch: %d", compressor.GetPressureSwitchValue()); //Prints value of value of the 
		ds->UpdateLCD();
	}
	
	void drive(){	//Teleoperated driving
		float leftSpeedMultiplier = 1;
		float rightSpeedMultiplier = 1;
		bool straight;
		if (leftStick.GetRawButton(3) && rightStick.GetRawButton(3)) {
			straight = true;
		}
		else straight = false;
		
		if(leftStick.GetRawButton(2)&& !straight) //Creep mode (trigger speed)
			leftSpeedMultiplier = CREEP_SPEED;
		if(rightStick.GetRawButton(2) && !straight) 
			rightSpeedMultiplier = CREEP_SPEED;
		if (straight) {
			leftDriveMotor.Set(-JOY_DIR * (leftStick.GetY() + rightStick.GetY()) / 2); //Go straight
			rightDriveMotor.Set(JOY_DIR * (leftStick.GetY() + rightStick.GetY()) / 2);
		}
		else {
			leftDriveMotor.Set(-JOY_DIR * leftStick.GetY() * leftSpeedMultiplier);
			rightDriveMotor.Set(JOY_DIR * rightStick.GetY() * rightSpeedMultiplier);
		}
		
	}
	
	float abs(float x){
		if(x < 0) return -x;
		return x;
	}
	
	void claw(){ // reads inputs from controllers and works the claw
		if(abs(gamepad.GetLeftY()) > GAMEPAD_JOY_THRESH){
			if(armSwitchBot.Get() && gamepad.GetLeftY() < 0);
			else if(armSwitchTop.Get() && gamepad.GetLeftY() > 0);
			else {
				if(armPID.IsEnabled()) armPID.Disable(); 
				arm.Set(GAMEPAD_JOY_DIR * gamepad.GetLeftY() * -1 * CLAW_SPEED);
			}
			
			holdPosition = armEncoder.GetDistance();
		}
		else {
			armPID.Enable();
			armPID.SetSetpoint(holdPosition);
		}
		rollers.Set(GAMEPAD_JOY_DIR * gamepad.GetRightY());
	}
	
	void shooter(){
		if(gamepad.GetButton(1)){
			rollers.Set(1);
			Wait(0.1);
			shooterSolenoid.Set(Relay::kForward); // use kForward not kOn
			Wait(0.1);
			rollers.Set(0);
		}
		else {
			shooterSolenoid.Set(Relay::kOff);
		}
	}
	
	void doRollers(){
		if(gamepad.GetButton(6)){
			rollers.Set(-0.75);
		}
		else {
			rollers.Set(0);
		}
	}
	
	void setAngle(){ //Set a nice shooting angle for the arm
		if(gamepad.GetButton(2)){
			armPID.Enable();
			armPID.SetSetpoint(6.4);	//CALIBRATE
			holdPosition = 6.4;
		}
	}
	/**
	 * Runs the motors with arcade steering. 
	 */
	void OperatorControl()
	{
		disableStraightPID();
		compressor.Start();
		compressor.SetRelayValue(Relay::kOn);
		
		armEncoder.Reset();
		armEncoder.Start();
		startArmPID();
		
		while (IsOperatorControl())
		{
			updateDriverStation();
			
			if(compressor.GetPressureSwitchValue()){
				compressor.SetRelayValue(Relay::kOff);
			}
			else {
				compressor.SetRelayValue(Relay::kOn);
			}
			
			drive();
			claw();
			shooter();
			doRollers();
			setAngle();
			
			
			doggy.Feed();
			
			Wait(0.005);				// wait for a motor update time
		}
	}
	
	/**
	 * Runs during test mode
	 */
	void Test() {

	}
};

START_ROBOT_CLASS(Robot);
